# import json
# import os
# from datetime import datetime

# class VulnerabilityDatabase:
#     def __init__(self, db_file='vulnerabilities.json'):
#         """
#         Initialize vulnerability database
        
#         :param db_file: Path to the JSON vulnerability database file
#         """
#         self.db_file = db_file
#         self.vulnerabilities = self._load_vulnerability_database()
    
#     def _load_vulnerability_database(self):
#         """
#         Load vulnerability database from JSON file
        
#         :return: Dictionary containing vulnerability data
#         """
#         try:
#             if os.path.exists(self.db_file):
#                 with open(self.db_file, 'r', encoding='utf-8') as f:
#                     return json.load(f)
#             else:
#                 print(f"Warning: Vulnerability database file '{self.db_file}' not found.")
#                 return {}
#         except Exception as e:
#             print(f"Error loading vulnerability database: {e}")
#             return {}
    
#     def match_port_vulnerabilities(self, open_ports):
#         """
#         Match open ports against known vulnerabilities
        
#         :param open_ports: Dictionary of open ports from network scan
#         :return: List of matched vulnerabilities
#         """
#         matched_vulnerabilities = []
        
#         if not open_ports:
#             return matched_vulnerabilities
        
#         # Iterate through detected open ports
#         for port_num, port_info in open_ports.items():
#             port_str = str(port_num)
#             service_name = port_info.get('service', '').lower()
            
#             # Check if port has known vulnerabilities
#             if 'ports' in self.vulnerabilities and port_str in self.vulnerabilities['ports']:
#                 port_vulns = self.vulnerabilities['ports'][port_str]
                
#                 for vuln in port_vulns:
#                     vulnerability = {
#                         'port': port_num,
#                         'service': port_info.get('service', 'Unknown'),
#                         'vulnerability_id': vuln.get('id', 'N/A'),
#                         'title': vuln.get('title', 'Unknown Vulnerability'),
#                         'description': vuln.get('description', 'No description available'),
#                         'severity': vuln.get('severity', 'Unknown'),
#                         'cvss_score': vuln.get('cvss_score', 'N/A'),
#                         'cve_id': vuln.get('cve_id', 'N/A'),
#                         'affected_services': vuln.get('affected_services', []),
#                         'remediation': vuln.get('remediation', 'No remediation information available'),
#                         'references': vuln.get('references', [])
#                     }
#                     matched_vulnerabilities.append(vulnerability)
        
#         return matched_vulnerabilities
    
#     def match_service_vulnerabilities(self, network_scan_data):
#         """
#         Match services against known vulnerabilities
        
#         :param network_scan_data: Complete network scan data
#         :return: List of matched vulnerabilities
#         """
#         matched_vulnerabilities = []
        
#         # Extract open ports from network scan data
#         open_ports = network_scan_data.get('open_ports', {})
        
#         # Match port-based vulnerabilities
#         port_vulns = self.match_port_vulnerabilities(open_ports)
#         matched_vulnerabilities.extend(port_vulns)
        
#         return matched_vulnerabilities
    
#     def generate_vulnerability_report(self, ip_address, vulnerabilities):
#         """
#         Generate a formatted vulnerability report
        
#         :param ip_address: Target IP address
#         :param vulnerabilities: List of matched vulnerabilities
#         :return: Formatted report string
#         """
#         report = f"Vulnerability Assessment Report for {ip_address}\n"
#         report += "=" * 60 + "\n"
#         report += f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
#         report += f"Total Vulnerabilities Found: {len(vulnerabilities)}\n\n"
        
#         if not vulnerabilities:
#             report += "No known vulnerabilities detected.\n\n"
#             report += "Recommendations:\n"
#             report += "1. Continue regular security updates\n"
#             report += "2. Maintain current security practices\n"
#             report += "3. Conduct periodic comprehensive security assessments\n"
#             return report
        
#         # Group vulnerabilities by severity
#         severity_groups = {}
#         for vuln in vulnerabilities:
#             severity = vuln.get('severity', 'Unknown')
#             if severity not in severity_groups:
#                 severity_groups[severity] = []
#             severity_groups[severity].append(vuln)
        
#         # Report vulnerabilities by severity (Critical, High, Medium, Low)
#         severity_order = ['Critical', 'High', 'Medium', 'Low', 'Unknown']
        
#         for severity in severity_order:
#             if severity in severity_groups:
#                 report += f"\n{severity.upper()} SEVERITY VULNERABILITIES\n"
#                 report += "-" * 40 + "\n"
                
#                 for vuln in severity_groups[severity]:
#                     report += f"Port: {vuln['port']} ({vuln['service']})\n"
#                     report += f"Vulnerability ID: {vuln['vulnerability_id']}\n"
#                     report += f"Title: {vuln['title']}\n"
#                     report += f"CVE ID: {vuln['cve_id']}\n"
#                     report += f"CVSS Score: {vuln['cvss_score']}\n"
#                     report += f"Description: {vuln['description']}\n"
#                     report += f"Remediation: {vuln['remediation']}\n"
                    
#                     if vuln['references']:
#                         report += "References:\n"
#                         for ref in vuln['references']:
#                             report += f"  - {ref}\n"
                    
#                     report += "\n" + "-" * 40 + "\n"
        
#         # Add general recommendations
#         report += "\nGENERAL RECOMMENDATIONS\n"
#         report += "-" * 30 + "\n"
#         report += "1. Apply security patches for identified vulnerabilities\n"
#         report += "2. Close unnecessary open ports\n"
#         report += "3. Implement network segmentation\n"
#         report += "4. Regular vulnerability assessments\n"
#         report += "5. Monitor system logs for suspicious activities\n"
        
#         return report


# def match_vulnerabilities(network_scan_data):
#     """
#     Convenience function to match vulnerabilities against network scan data
    
#     :param network_scan_data: Network scan data dictionary
#     :return: List of matched vulnerabilities
#     """
#     vuln_db = VulnerabilityDatabase()
#     return vuln_db.match_service_vulnerabilities(network_scan_data)


# def generate_vulnerability_report(ip_address, vulnerabilities):
#     """
#     Convenience function to generate vulnerability report
    
#     :param ip_address: Target IP address
#     :param vulnerabilities: List of vulnerabilities
#     :return: Formatted report string
#     """
#     vuln_db = VulnerabilityDatabase()
#     return vuln_db.generate_vulnerability_report(ip_address, vulnerabilities)

import json
import os
from datetime import datetime

class VulnerabilityDatabase:
    def __init__(self, db_file='vulnerabilities.json'):
        """
        Initialize vulnerability database
        
        :param db_file: Path to the JSON vulnerability database file
        """
        self.db_file = db_file
        self.vulnerabilities = self._load_vulnerability_database()
    
    def _load_vulnerability_database(self):
        """
        Load vulnerability database from JSON file
        
        :return: Dictionary containing vulnerability data
        """
        try:
            if os.path.exists(self.db_file):
                with open(self.db_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            else:
                print(f"Warning: Vulnerability database file '{self.db_file}' not found.")
                return {}
        except Exception as e:
            print(f"Error loading vulnerability database: {e}")
            return {}
    
    def match_port_vulnerabilities(self, open_ports):
        """
        Match open ports against known vulnerabilities
        
        :param open_ports: Dictionary of open ports from network scan
        :return: List of matched vulnerabilities
        """
        matched_vulnerabilities = []
        
        if not open_ports:
            return matched_vulnerabilities
        
        # Iterate through detected open ports
        for port_num, port_info in open_ports.items():
            port_str = str(port_num)
            service_name = port_info.get('service', '').lower()
            
            # Check if port has known vulnerabilities
            if 'ports' in self.vulnerabilities and port_str in self.vulnerabilities['ports']:
                port_vulns = self.vulnerabilities['ports'][port_str]
                
                for vuln in port_vulns:
                    vulnerability = {
                        'port': port_num,
                        'service': port_info.get('service', 'Unknown'),
                        'vulnerability_id': vuln.get('id', 'N/A'),
                        'title': vuln.get('title', 'Unknown Vulnerability'),
                        'description': vuln.get('description', 'No description available'),
                        'severity': vuln.get('severity', 'Unknown'),
                        'cvss_score': vuln.get('cvss_score', 'N/A'),
                        'cve_id': vuln.get('cve_id', 'N/A'),
                        'affected_services': vuln.get('affected_services', []),
                        'remediation': vuln.get('remediation', 'No remediation information available'),
                        'references': vuln.get('references', [])
                    }
                    matched_vulnerabilities.append(vulnerability)
        
        return matched_vulnerabilities
    
    def match_service_vulnerabilities(self, network_scan_data):
        """
        Match services against known vulnerabilities
        
        :param network_scan_data: Complete network scan data
        :return: List of matched vulnerabilities
        """
        matched_vulnerabilities = []
        
        # Extract open ports from network scan data
        open_ports = network_scan_data.get('open_ports', {})
        
        # Match port-based vulnerabilities
        port_vulns = self.match_port_vulnerabilities(open_ports)
        matched_vulnerabilities.extend(port_vulns)
        
        return matched_vulnerabilities
    
    def generate_vulnerability_report_json(self, ip_address, vulnerabilities):
        """
        Generate a JSON vulnerability report
        
        :param ip_address: Target IP address
        :param vulnerabilities: List of matched vulnerabilities
        :return: Dictionary containing structured report data
        """
        report = {
            "target_ip": ip_address,
            "scan_date": datetime.now().isoformat(),
            "total_vulnerabilities": len(vulnerabilities),
            "vulnerabilities": [],
            "summary": {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0,
                "unknown": 0
            },
            "recommendations": []
        }
        
        if not vulnerabilities:
            report["status"] = "No vulnerabilities detected"
            report["recommendations"] = [
                "Continue regular security updates",
                "Maintain current security practices",
                "Conduct periodic comprehensive security assessments"
            ]
            return report
        
        # Process vulnerabilities
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'Unknown').lower()
            if severity in report["summary"]:
                report["summary"][severity] += 1
            else:
                report["summary"]["unknown"] += 1
            
            report["vulnerabilities"].append(vuln)
        
        # Add general recommendations
        report["recommendations"] = [
            "Apply security patches for identified vulnerabilities",
            "Close unnecessary open ports",
            "Implement network segmentation",
            "Regular vulnerability assessments",
            "Monitor system logs for suspicious activities"
        ]
        
        return report
    
    def generate_vulnerability_report(self, ip_address, vulnerabilities):
        """
        Generate a formatted vulnerability report (text format - kept for backward compatibility)
        
        :param ip_address: Target IP address
        :param vulnerabilities: List of matched vulnerabilities
        :return: Formatted report string
        """
        report = f"Vulnerability Assessment Report for {ip_address}\n"
        report += "=" * 60 + "\n"
        report += f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        report += f"Total Vulnerabilities Found: {len(vulnerabilities)}\n\n"
        
        if not vulnerabilities:
            report += "No known vulnerabilities detected.\n\n"
            report += "Recommendations:\n"
            report += "1. Continue regular security updates\n"
            report += "2. Maintain current security practices\n"
            report += "3. Conduct periodic comprehensive security assessments\n"
            return report
        
        # Group vulnerabilities by severity
        severity_groups = {}
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'Unknown')
            if severity not in severity_groups:
                severity_groups[severity] = []
            severity_groups[severity].append(vuln)
        
        # Report vulnerabilities by severity (Critical, High, Medium, Low)
        severity_order = ['Critical', 'High', 'Medium', 'Low', 'Unknown']
        
        for severity in severity_order:
            if severity in severity_groups:
                report += f"\n{severity.upper()} SEVERITY VULNERABILITIES\n"
                report += "-" * 40 + "\n"
                
                for vuln in severity_groups[severity]:
                    report += f"Port: {vuln['port']} ({vuln['service']})\n"
                    report += f"Vulnerability ID: {vuln['vulnerability_id']}\n"
                    report += f"Title: {vuln['title']}\n"
                    report += f"CVE ID: {vuln['cve_id']}\n"
                    report += f"CVSS Score: {vuln['cvss_score']}\n"
                    report += f"Description: {vuln['description']}\n"
                    report += f"Remediation: {vuln['remediation']}\n"
                    
                    if vuln['references']:
                        report += "References:\n"
                        for ref in vuln['references']:
                            report += f"  - {ref}\n"
                    
                    report += "\n" + "-" * 40 + "\n"
        
        # Add general recommendations
        report += "\nGENERAL RECOMMENDATIONS\n"
        report += "-" * 30 + "\n"
        report += "1. Apply security patches for identified vulnerabilities\n"
        report += "2. Close unnecessary open ports\n"
        report += "3. Implement network segmentation\n"
        report += "4. Regular vulnerability assessments\n"
        report += "5. Monitor system logs for suspicious activities\n"
        
        return report


def match_vulnerabilities(network_scan_data):
    """
    Convenience function to match vulnerabilities against network scan data
    
    :param network_scan_data: Network scan data dictionary
    :return: List of matched vulnerabilities
    """
    vuln_db = VulnerabilityDatabase()
    return vuln_db.match_service_vulnerabilities(network_scan_data)


def generate_vulnerability_report(ip_address, vulnerabilities):
    """
    Convenience function to generate vulnerability report (text format)
    
    :param ip_address: Target IP address
    :param vulnerabilities: List of vulnerabilities
    :return: Formatted report string
    """
    vuln_db = VulnerabilityDatabase()
    return vuln_db.generate_vulnerability_report(ip_address, vulnerabilities)


def generate_vulnerability_report_json(ip_address, vulnerabilities):
    """
    Convenience function to generate vulnerability report (JSON format)
    
    :param ip_address: Target IP address
    :param vulnerabilities: List of vulnerabilities
    :return: Dictionary containing structured report data
    """
    vuln_db = VulnerabilityDatabase()
    return vuln_db.generate_vulnerability_report_json(ip_address, vulnerabilities)