# import json
# import os
# from datetime import datetime

# class VulnerabilityDatabase:
#     def __init__(self, db_file='vulnerabilities.json'):
#         """
#         Initialize vulnerability database
        
#         :param db_file: Path to the JSON vulnerability database file
#         """
#         self.db_file = db_file
#         self.vulnerabilities = self._load_vulnerability_database()
    
#     def _load_vulnerability_database(self):
#         """
#         Load vulnerability database from JSON file
        
#         :return: Dictionary containing vulnerability data
#         """
#         try:
#             if os.path.exists(self.db_file):
#                 with open(self.db_file, 'r', encoding='utf-8') as f:
#                     return json.load(f)
#             else:
#                 print(f"Warning: Vulnerability database file '{self.db_file}' not found.")
#                 return {}
#         except Exception as e:
#             print(f"Error loading vulnerability database: {e}")
#             return {}
    
#     def match_port_vulnerabilities(self, open_ports):
#         """
#         Match open ports against known vulnerabilities
        
#         :param open_ports: Dictionary of open ports from network scan
#         :return: List of matched vulnerabilities
#         """
#         matched_vulnerabilities = []
        
#         if not open_ports:
#             return matched_vulnerabilities
        
#         # Iterate through detected open ports
#         for port_num, port_info in open_ports.items():
#             port_str = str(port_num)
#             service_name = port_info.get('service', '').lower()
            
#             # Check if port has known vulnerabilities
#             if 'ports' in self.vulnerabilities and port_str in self.vulnerabilities['ports']:
#                 port_vulns = self.vulnerabilities['ports'][port_str]
                
#                 for vuln in port_vulns:
#                     vulnerability = {
#                         'port': port_num,
#                         'service': port_info.get('service', 'Unknown'),
#                         'vulnerability_id': vuln.get('id', 'N/A'),
#                         'title': vuln.get('title', 'Unknown Vulnerability'),
#                         'description': vuln.get('description', 'No description available'),
#                         'severity': vuln.get('severity', 'Unknown'),
#                         'cvss_score': vuln.get('cvss_score', 'N/A'),
#                         'cve_id': vuln.get('cve_id', 'N/A'),
#                         'affected_services': vuln.get('affected_services', []),
#                         'remediation': vuln.get('remediation', 'No remediation information available'),
#                         'references': vuln.get('references', [])
#                     }
#                     matched_vulnerabilities.append(vulnerability)
        
#         return matched_vulnerabilities
    
#     def match_service_vulnerabilities(self, network_scan_data):
#         """
#         Match services against known vulnerabilities
        
#         :param network_scan_data: Complete network scan data
#         :return: List of matched vulnerabilities
#         """
#         matched_vulnerabilities = []
        
#         # Extract open ports from network scan data
#         open_ports = network_scan_data.get('open_ports', {})
        
#         # Match port-based vulnerabilities
#         port_vulns = self.match_port_vulnerabilities(open_ports)
#         matched_vulnerabilities.extend(port_vulns)
        
#         return matched_vulnerabilities
    
#     def generate_vulnerability_report(self, ip_address, vulnerabilities):
#         """
#         Generate a formatted vulnerability report
        
#         :param ip_address: Target IP address
#         :param vulnerabilities: List of matched vulnerabilities
#         :return: Formatted report string
#         """
#         report = f"Vulnerability Assessment Report for {ip_address}\n"
#         report += "=" * 60 + "\n"
#         report += f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
#         report += f"Total Vulnerabilities Found: {len(vulnerabilities)}\n\n"
        
#         if not vulnerabilities:
#             report += "No known vulnerabilities detected.\n\n"
#             report += "Recommendations:\n"
#             report += "1. Continue regular security updates\n"
#             report += "2. Maintain current security practices\n"
#             report += "3. Conduct periodic comprehensive security assessments\n"
#             return report
        
#         # Group vulnerabilities by severity
#         severity_groups = {}
#         for vuln in vulnerabilities:
#             severity = vuln.get('severity', 'Unknown')
#             if severity not in severity_groups:
#                 severity_groups[severity] = []
#             severity_groups[severity].append(vuln)
        
#         # Report vulnerabilities by severity (Critical, High, Medium, Low)
#         severity_order = ['Critical', 'High', 'Medium', 'Low', 'Unknown']
        
#         for severity in severity_order:
#             if severity in severity_groups:
#                 report += f"\n{severity.upper()} SEVERITY VULNERABILITIES\n"
#                 report += "-" * 40 + "\n"
                
#                 for vuln in severity_groups[severity]:
#                     report += f"Port: {vuln['port']} ({vuln['service']})\n"
#                     report += f"Vulnerability ID: {vuln['vulnerability_id']}\n"
#                     report += f"Title: {vuln['title']}\n"
#                     report += f"CVE ID: {vuln['cve_id']}\n"
#                     report += f"CVSS Score: {vuln['cvss_score']}\n"
#                     report += f"Description: {vuln['description']}\n"
#                     report += f"Remediation: {vuln['remediation']}\n"
                    
#                     if vuln['references']:
#                         report += "References:\n"
#                         for ref in vuln['references']:
#                             report += f"  - {ref}\n"
                    
#                     report += "\n" + "-" * 40 + "\n"
        
#         # Add general recommendations
#         report += "\nGENERAL RECOMMENDATIONS\n"
#         report += "-" * 30 + "\n"
#         report += "1. Apply security patches for identified vulnerabilities\n"
#         report += "2. Close unnecessary open ports\n"
#         report += "3. Implement network segmentation\n"
#         report += "4. Regular vulnerability assessments\n"
#         report += "5. Monitor system logs for suspicious activities\n"
        
#         return report


# def match_vulnerabilities(network_scan_data):
#     """
#     Convenience function to match vulnerabilities against network scan data
    
#     :param network_scan_data: Network scan data dictionary
#     :return: List of matched vulnerabilities
#     """
#     vuln_db = VulnerabilityDatabase()
#     return vuln_db.match_service_vulnerabilities(network_scan_data)


# def generate_vulnerability_report(ip_address, vulnerabilities):
#     """
#     Convenience function to generate vulnerability report
    
#     :param ip_address: Target IP address
#     :param vulnerabilities: List of vulnerabilities
#     :return: Formatted report string
#     """
#     vuln_db = VulnerabilityDatabase()
#     return vuln_db.generate_vulnerability_report(ip_address, vulnerabilities)

import json
import requests
from datetime import datetime

class VulnerabilityDatabase:
    def __init__(self):
        pass  # No local JSON database used

    def match_external_vulnerabilities(self, network_data):
        matched_vulnerabilities = []
        open_ports = network_data.get('open_ports', {})
        banners = network_data.get('banners', {})
        system_info = network_data.get('system_info', {})

        for port, info in open_ports.items():
            service = info.get('service', 'unknown')
            banner = banners.get(str(port), '')
            cve_info = self._search_vulners_with_fallback(service, banner, system_info, port)

            vuln = {
                'port': port,
                'service': service,
                'banner': banner,
                'exploit_links': self._exploitdb_links(service, port),
                'cve': cve_info.get('cve') if cve_info else 'N/A',
                'cvss': cve_info.get('cvss') if cve_info else 'N/A',
                'summary': cve_info.get('summary') if cve_info else 'No summary available',
                'cve_link': cve_info.get('href') if cve_info else ''
            }

            matched_vulnerabilities.append(vuln)

        return matched_vulnerabilities

    def _exploitdb_links(self, service, port):
        if not service:
            return []
        base = f"https://www.exploit-db.com/search?q={service.replace(' ', '+')}&port={port}"
        return [
            f"{base}&platform=windows",
            f"{base}&platform=windows_x86",
            f"{base}&platform=windows_x86-64"
        ]

    def _search_vulners_with_fallback(self, service, banner, system_info=None, port=None):
        queries = []

        if service or banner:
            queries.append(f"{service} {banner}".strip())

        if system_info:
            os_info = system_info.get("os", {})
            os_name = os_info.get("name", "")
            build = os_info.get("build_number", "")
            arch = os_info.get("architecture", "")
            queries.append(f"{service} {os_name} {build} {arch}".strip())
            if build:
                queries.append(f"{os_name} build {build}".strip())
            if arch:
                queries.append(f"{service} {arch}".strip())

        for q in queries:
            cve = self._search_vulners(q)
            if cve and cve.get("cve"):
                return cve

        for q in queries:
            cve = self._search_circl(q)
            if cve and cve.get("cve"):
                return cve

        return None

    def _search_vulners(self, query):
        try:
            headers = {'User-Agent': 'VulnChecker'}
            url = f"https://vulners.com/api/v3/search/lucene/?query={query}"
            resp = requests.get(url, headers=headers, timeout=4)
            if resp.status_code == 200:
                data = resp.json()
                results = data.get('data', {}).get('documents', [])
                if results:
                    top = results[0]
                    return {
                        'cve': top.get('cvelist', [''])[0],
                        'cvss': top.get('cvss', 'N/A'),
                        'summary': top.get('description', '')[:150],
                        'href': top.get('href', '')
                    }
        except:
            pass
        return None

    def _search_circl(self, query):
        try:
            base_url = "https://cve.circl.lu/api/search/"
            url = f"{base_url}{query.replace(' ', '%20')}"
            resp = requests.get(url, timeout=4)
            if resp.status_code == 200:
                results = resp.json().get('results', [])
                if results:
                    top = results[0]
                    return {
                        'cve': top.get('id'),
                        'cvss': top.get('cvss', 'N/A'),
                        'summary': top.get('summary', '')[:150],
                        'href': f"https://cve.circl.lu/api/cve/{top.get('id')}"
                    }
        except:
            pass
        return None

    def generate_vulnerability_report_json(self, ip_address, vulnerabilities):
        report = {
            "target_ip": ip_address,
            "scan_date": datetime.now().isoformat(),
            "total_vulnerabilities": len(vulnerabilities),
            "vulnerabilities": vulnerabilities,
            "summary": {},
            "recommendations": [
                "Review externally matched vulnerabilities",
                "Check ExploitDB and CVE links",
                "Patch affected services and close unnecessary ports"
            ]
        }
        return report

    def generate_vulnerability_report(self, ip_address, vulnerabilities):
        report = f"External Vulnerability Report for {ip_address}\n{'='*60}\n"
        report += f"Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
        report += f"Total Matches: {len(vulnerabilities)}\n\n"

        for vuln in vulnerabilities:
            report += f"Port: {vuln['port']} ({vuln['service']})\n"
            report += f"Banner: {vuln.get('banner', '')}\n"
            report += f"Exploit Links:\n"
            for link in vuln['exploit_links']:
                report += f"  - {link}\n"
            report += f"CVE: {vuln.get('cve', 'N/A')}\n"
            report += f"CVSS: {vuln.get('cvss', 'N/A')}\n"
            report += f"Summary: {vuln.get('summary', 'No summary available')}\n"
            report += f"CVE Link: {vuln.get('cve_link', '')}\n"
            report += '-'*40 + '\n'

        return report


# Convenience wrappers
def match_vulnerabilities(network_scan_data):
    return VulnerabilityDatabase().match_external_vulnerabilities(network_scan_data)

def generate_vulnerability_report(ip_address, vulnerabilities):
    return VulnerabilityDatabase().generate_vulnerability_report(ip_address, vulnerabilities)

def generate_vulnerability_report_json(ip_address, vulnerabilities):
    return VulnerabilityDatabase().generate_vulnerability_report_json(ip_address, vulnerabilities)
